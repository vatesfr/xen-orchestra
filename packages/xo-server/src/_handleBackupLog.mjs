import humanFormat from 'human-format'
import ms from 'ms'

const vmBackupInfo = new Map()

function sendToNagios(app, jobName, vmBackupInfo) {
  try {
    vmBackupInfo.size = humanFormat(vmBackupInfo.size, { scale: 'binary', unit: 'B' })
    vmBackupInfo.duration = ms(vmBackupInfo.end - vmBackupInfo.start)

    delete vmBackupInfo.type
    delete vmBackupInfo.start
    delete vmBackupInfo.end

    app.sendPassiveCheck(
      {
        message: JSON.stringify(vmBackupInfo),
        status: 0,
      },
      app.getObject(vmBackupInfo.vmId).name_label.toLowerCase(),
      jobName
    )
  } catch (error) {
    console.warn(error)
  }
}

function forwardResult(log) {
  if (log.status === 'failure') {
    throw log.result
  }
  return log.result
}

// it records logs generated by `@xen-orchestra/backups/Task#run`
export const handleBackupLog = (
  app,
  jobName = undefined,
  log,
  { logger, localTaskIds, rootTaskId, runJobId = rootTaskId, handleRootTaskId }
) => {
  const { event, message, parentId, taskId } = log

  if (jobName) {
    if (event === 'start') {
      if (log.data?.type === 'VM') {
        vmBackupInfo.set(taskId, {
          type: 'VM',
          vmId: log.data.id,
          start: log.timestamp,
        })
      } else if (vmBackupInfo.get(parentId)?.type === 'VM' && log.message === 'export') {
        vmBackupInfo.set(taskId, {
          type: 'export',
          parentId,
        })
      } else if (vmBackupInfo.get(parentId)?.type === 'export' && log.message === 'transfer') {
        vmBackupInfo.set(taskId, {
          type: 'transfer',
          parentId,
        })
      }
    } else if (event === 'end') {
      if (vmBackupInfo.get(taskId)?.type === 'VM') {
        const data = vmBackupInfo.get(taskId)
        data.result = log.status
        data.end = log.timestamp
        sendToNagios(app, jobName, data)
      } else if (vmBackupInfo.get(taskId)?.type === 'transfer') {
        vmBackupInfo.get(vmBackupInfo.get(vmBackupInfo.get(taskId).parentId).parentId).size = log.result.size
      }
    }
  }

  // If `runJobId` is defined, it means that the root task is already handled by `runJob`
  if (runJobId !== undefined) {
    // Ignore the start of the root task
    if (event === 'start' && log.parentId === undefined) {
      localTaskIds[taskId] = runJobId
      return
    }

    // Return/throw the result of the root task
    if (event === 'end' && localTaskIds[taskId] === runJobId) {
      return forwardResult(log)
    }
  }

  const common = {
    data: log.data,
    event: 'task.' + event,
    result: log.result,
    status: log.status,
  }

  if (event === 'start') {
    const { parentId } = log
    if (parentId === undefined) {
      handleRootTaskId((localTaskIds[taskId] = logger.notice(message, common)))
    } else {
      common.parentId = localTaskIds[parentId]
      localTaskIds[taskId] = logger.notice(message, common)
    }
  } else {
    common.taskId = localTaskIds[taskId]
    logger.notice(message, common)
  }

  // special case for the end of the root task: return/throw the result
  if (event === 'end' && localTaskIds[taskId] === rootTaskId) {
    return forwardResult(log)
  }
}
