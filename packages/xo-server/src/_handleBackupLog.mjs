import moment from 'moment-timezone'
import humanFormat from 'human-format'

let vmBackupInfo = {}

function sendToNagios(app, vmBackupInfo) {
  app.sendPassiveCheck({
    message: JSON.stringify(vmBackupInfo),
    status: 0
  }, vmBackupInfo.vmName.toLowerCase(), vmBackupInfo.jobName)
}

function forwardResult(log) {
  if (log.status === 'failure') {
    throw log.result
  }
  return log.result
}

// it records logs generated by `@xen-orchestra/backups/Task#run`
export const handleBackupLog = (app, jobName, log, { logger, localTaskIds, rootTaskId, runJobId = rootTaskId, handleRootTaskId }) => {
  const { event, message, taskId } = log
  if (log.data && log.data.type && log.data.type === 'VM') {
    vmBackupInfo[log.taskId] = {
      vmId: log.data.id,
      vmName: app._objects._items[log.data.id].name_label,
      jobName: jobName,
      startTimestamp: log.timestamp
    }
  }
  
  // If `runJobId` is defined, it means that the root task is already handled by `runJob`
  if (runJobId !== undefined) {
    // Ignore the start of the root task
    if (event === 'start' && log.parentId === undefined) {
      localTaskIds[taskId] = runJobId
      return
    }

    // Return/throw the result of the root task
    if (event === 'end' && localTaskIds[taskId] === runJobId) {
      return forwardResult(log)
    }
  }

  const common = {
    data: log.data,
    event: 'task.' + event,
    result: log.result,
    status: log.status,
  }

  if (event === 'start') {
    const { parentId } = log
    if (parentId === undefined) {
      handleRootTaskId((localTaskIds[taskId] = logger.notice(message, common)))
    } else {
      common.parentId = localTaskIds[parentId]
      localTaskIds[taskId] = logger.notice(message, common)
    }
  } else {
    common.taskId = localTaskIds[taskId]
    logger.notice(message, common)
  }

  if (log.message && log.message === 'export') {
    vmBackupInfo[log.parentId]['exportId'] = log.taskId
  }

  if (log.message && log.message === 'transfer') {
    Object.keys(vmBackupInfo).forEach(key => {
      if (vmBackupInfo[key].hasOwnProperty('exportId') && vmBackupInfo[key].exportId === log.parentId) {
        vmBackupInfo[key]['transferId'] = log.taskId
      }
    })
  }

  if (log.result && log.result.size) {
    Object.keys(vmBackupInfo).forEach(key => {
      if (vmBackupInfo[key].hasOwnProperty('transferId') && vmBackupInfo[key].transferId === log.taskId) {
        vmBackupInfo[key]['size'] = humanFormat(log.result.size, { scale: 'binary', unit: 'B' })
        delete vmBackupInfo[key].exportId
        delete vmBackupInfo[key].transferId
      }
    })
  }

  if (event === 'end' && vmBackupInfo.hasOwnProperty(log.taskId)) {
    vmBackupInfo[log.taskId]['status'] = log.status
    vmBackupInfo[log.taskId]['duration'] = moment.duration(log.timestamp - vmBackupInfo[log.taskId].startTimestamp).humanize()
    delete vmBackupInfo[log.taskId].startTimestamp

    sendToNagios(app, vmBackupInfo[log.taskId])
  }

  // special case for the end of the root task: return/throw the result
  if (event === 'end' && localTaskIds[taskId] === rootTaskId) {
    return forwardResult(log)
  }
}
