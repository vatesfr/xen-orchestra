import humanFormat from 'human-format'
import ms from 'ms'
import { createLogger } from '@xen-orchestra/log'
import { strict as assert } from 'node:assert'

const { warn } = createLogger('xo:server:handleBackupLog')

async function sendToNagios(app, jobName, vmBackupInfo) {
  if (app.sendPassiveCheck === undefined) {
    // Nagios plugin is not loaded
    return
  }

  try {
    const messageToNagios = {
      id: vmBackupInfo.id,
      result: vmBackupInfo.result,
      size: humanFormat.bytes(vmBackupInfo.size),
      duration: ms(vmBackupInfo.end - vmBackupInfo.start),
    }

    await app.sendPassiveCheck(
      {
        message: JSON.stringify(messageToNagios),
        status: 0,
      },
      app.getObject(messageToNagios.id).name_label,
      jobName
    )
  } catch (error) {
    warn('sendToNagios:', { error })
  }
}

function forwardResult(log) {
  if (log.status === 'failure') {
    throw log.result
  }
  return log.result
}

// it records logs generated by `@xen-orchestra/backups/Task#run`
// will be removed
export const handleBackupLog = (
  log,
  { vmBackupInfo, app, jobName, logger, localTaskIds, rootTaskId, runJobId, handleRootTaskId }
) => {
  const { event, message, parentId, taskId } = log

  if (app !== undefined && jobName !== undefined) {
    if (event === 'start') {
      if (log.data?.type === 'VM') {
        vmBackupInfo.set('vm-' + taskId, {
          id: log.data.id,
          start: log.timestamp,
        })
      } else if (vmBackupInfo.has('vm-' + parentId) && log.message === 'export') {
        vmBackupInfo.set('export-' + taskId, {
          parentId: 'vm-' + parentId,
        })
      } else if (vmBackupInfo.has('export-' + parentId) && log.message === 'transfer') {
        vmBackupInfo.set('transfer-' + taskId, {
          parentId: 'export-' + parentId,
        })
      }
    } else if (event === 'end') {
      if (vmBackupInfo.has('vm-' + taskId)) {
        const data = vmBackupInfo.get('vm-' + taskId)
        data.result = log.status
        data.end = log.timestamp
        sendToNagios(app, jobName, data)
      } else if (vmBackupInfo.has('transfer-' + taskId)) {
        vmBackupInfo.get(vmBackupInfo.get(vmBackupInfo.get('transfer-' + taskId).parentId).parentId).size =
          log.result.size
      }
    }
  }

  // If `runJobId` is defined, it means that the root task is already handled by `runJob`
  if (runJobId !== undefined) {
    // Ignore the start of the root task
    if (event === 'start' && log.parentId === undefined) {
      localTaskIds[taskId] = runJobId
      return
    }

    // Return/throw the result of the root task
    if (event === 'end' && localTaskIds[taskId] === runJobId) {
      return forwardResult(log)
    }
  }

  const common = {
    data: log.data,
    event: 'task.' + event,
    result: log.result,
    status: log.status,
  }

  if (event === 'start') {
    const { parentId } = log
    if (parentId === undefined) {
      handleRootTaskId((localTaskIds[taskId] = logger.notice(message, common)))
    } else {
      common.parentId = localTaskIds[parentId]
      localTaskIds[taskId] = logger.notice(message, common)
    }
  } else {
    common.taskId = localTaskIds[taskId]
    logger.notice(message, common)
  }

  // special case for the end of the root task: return/throw the result
  if (event === 'end' && localTaskIds[taskId] === rootTaskId) {
    return forwardResult(log)
  }
}

// temporary name - will replace handleBackupLog
export const handleBackupTaskLog = (
  { app, handleRootTaskId, jobName, localTaskIds, store },
) => {
  const taskLogs = new Map()
  return function onProgress(event) {
    const { id, type } = event
    let taskLog
    if (type === 'start') {
      taskLog = {
        id,
        properties: { __proto__: null, ...event.properties },
        start: event.timestamp,
        status: 'pending',
      }
      taskLogs.set(id, taskLog)

      const { parentId } = event
      if (parentId === undefined) {
        // start of a root task
        Object.defineProperty(taskLog, '$root', { value: taskLog })
      } else {
        // start of a subtask
        const parent = taskLogs.get(parentId)
        assert.notEqual(parent, undefined)

        // inject a (non-enumerable) reference to the parent and the root task
        Object.defineProperties(taskLog, { $parent: { value: parent }, $root: { value: parent.$root } })
        ;(parent.tasks ?? (parent.tasks = [])).push(taskLog)
      }
    } else {
      taskLog = taskLogs.get(id)
      assert.notEqual(taskLog, undefined)

      if (type === 'info' || type === 'warning') {
        const key = type + 's'
        const { data, message } = event
        ;(taskLog[key] ?? (taskLog[key] = [])).push({ data, message })
      } else if (type === 'property') {
        ;(taskLog.properties ?? (taskLog.properties = { __proto__: null }))[event.name] = event.value
      } else if (type === 'end') {
        taskLogs.delete(id)

        taskLog.end = event.timestamp
        taskLog.result = event.result
        taskLog.status = event.status
      } else if (type === 'abortionRequested') {
        taskLog.abortionRequestedAt = event.timestamp
      }

    }


    // sending data to Nagios
    if (app !== undefined && jobName !== undefined) {
      if (type === 'end' && taskLog.properties?.type === 'VM') {
        // we arbitrary pick one transfer to get the size
        const exportTask = taskLog.tasks.find((task) => task.properties?.name === 'export')
        const transferTask = exportTask === undefined ? undefined : exportTask.tasks.find((task) => task.properties?.name === 'transfer')
        const vmBackupInfo = {
          start: taskLog.start,
          id: taskLog.properties?.id,
          result: taskLog.status,
          end: taskLog.end,
          size: transferTask?.result?.size
        }
        sendToNagios(app, jobName, vmBackupInfo)
      }
    }

    // localTaskIds may not be relevant anymore
    localTaskIds[id] = taskLog.id
    if (type === 'start' && taskLog.$parent?.id === undefined && handleRootTaskId !== undefined) {
      handleRootTaskId(localTaskIds[id])
    }

    store.put(taskLog.$root.id, taskLog.$root)

    // end of the root task: return/throw the result
    if (type === 'end' && taskLog.$root === taskLog) {
      return forwardResult(taskLog)
    }
  }
}
