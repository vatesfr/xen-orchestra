import angular from 'angular'
import filter from 'lodash.filter'
import xoApi from 'xo-api'
import xoNotify from 'xo-notify'

const {isString} = angular

const isPlainObject = (function (toS) {
  const ref = toS.call({})
  return (value) => value != null && toS.call(value) === ref
})(Object.prototype.toString)

// ===================================================================

// High level integration of XO API in xo-web.
export default angular.module('xo', [
  xoApi,
  xoNotify
])
  .service('xo', function (xoApi, xoNotify) {
    // FIXME: default mapper should be identity.
    const defaultArgsMapper = (...args) => {
      const {length} = args

      // No arguments.
      if (!length) {
        return {}
      }

      if (length !== 1) {
        throw new Error('no obvious mapping: more than one argument')
      }

      const arg = args[0]

      // The only argument is an object, it is probably the arguments,
      // therefore it should be forwarded.
      if (isPlainObject(arg)) {
        return arg
      }

      // The only argument is a string, attempts to match it as `id`.
      if (isString(arg)) {
        return { id: arg }
      }

      throw new Error('no obvious mapping: the only argument is neither an object or a string')
    }

    const action = (name, method, options) => {
      if (!method) {
        return () => {
          xoNotify.info({
            title: name,
            message: 'This feature has not been implemented yet.'
          })

          // TODO: A (broken) promise should be returned for
          // consistency.
        }
      }

      const {
        argsMapper = defaultArgsMapper,
        notification
      } = options || {}

      return (...args) => {
        const promise = xoApi.call(method, argsMapper(...args))

        promise.catch(error => {
          console.error('Error for %s:', method, error)

          if (notification !== false) {
            const message = (error && error.code === 2) ?
              'You don\'t have the permission.' :
              'The action failed for unknown reason.'

            xoNotify.warning({
              title: name,
              message
            })
          }
        })

        return promise
      }
    }

    /* eslint key-spacing: 0 */

    // The interface.
    const xo = {
      acl: {
        add: action('Adding an ACL entry', 'acl.add', {
          argsMapper: (subject, object, action) => ({subject, object, action})
        }),
        get: action('Getting ACLs', 'acl.get'),
        remove: action('Remove an ACL entry', 'acl.remove', {
          argsMapper: (subject, object, action) => ({subject, object, action})
        })
      },

      disk: {
        create: action('Create disk', 'disk.create', {
          argsMapper: (name, size, sr) => ({name, size, sr})
        })
      },

      pool: {
        disconnect: action('Disconnect pool'),
        new_sr: action('New SR'), // temp fix before creating SR
        patch: action('Upload patch', 'pool.patch', {
          argsMapper: (pool) => ({pool})
        })
      },

      host: {
        attach:           action('Attach host'),
        detach:           action('Detach host', 'host.detach'),
        restart:          action('Restart host', 'host.restart'),
        restartToolStack: action('Restart tool stack', 'host.restart_agent'),
        start:            action('Start host', 'host.start'),
        enable:           action('Enable host', 'host.enable'),
        stop:             action('Stop host', 'host.stop'),
        disable:          action('Disable host', 'host.disable'),
        new_sr:           action('New SR'), // temp fix before creating SR
        listMissingPatches: action('Check available patches', 'host.listMissingPatches', {
          argsMapper: (host) => ({host})
        }),
        installPatch:     action('Install a patch from a patch id', 'host.installPatch', {
          argsMapper: (host, patch) => ({host, patch})
        }),
        refreshStats: action('Get Stats', 'host.stats', {
          notification: false,
          argsMapper: (host) => ({host})
        })
        // TODO: attach/set
      },

      log: {
        delete: action('Delete Log', 'message.delete')
      },

      message: {
        delete: action('Delete message')
      },

      pbd: {
        delete: action('Delete PBD'),
        disconnect: action('Disconnect PBD')
      },

      server: {
        add: action('Add server', 'server.add'),
        remove: action('Remove server', 'server.remove'),
        getAll: action('Getting server', 'server.getAll'),
        set: action('Save server', 'server.set'),
        connect: action('Connect to a server', 'server.connect', {
          notification: false
        }),
        disconnect: action('Disconnect from a server', 'server.disconnect')
      },

      task: {
        cancel: action('Cancel task', 'task.cancel'),
        destroy: action('Destroy task', 'task.destroy')
      },

      user: {
        create: action('Create user', 'user.create'),
        delete: action('Delete user', 'user.delete', {
          argsMapper: (id) => ({ id: String(id) })
        }),
        getAll: action('Getting users', 'user.getAll'),
        set: action('Save user', 'user.set')
      },

      group: {
        create: action('Create group', 'group.create'),
        delete: action('Delete group', 'group.delete', {
          argsMapper: (id) => ({ id: String(id) })
        }),
        getAll: action('Getting groups', 'group.getAll'),
        set: action('Save group', 'group.set'),
        setUsers: action('Set group users', 'group.setUsers', {
          argsMapper: (id, userIds) => ({ id: String(id), userIds})
        }),
        addUser: action('Add group user', 'group.addUser', {
          argsMapper: (id, userId) => ({ id: String(id), userId: String(userId)})
        }),
        removeUser: action('Remove group users', 'group.removeUser', {
          argsMapper: (id, userId) => ({ id: String(id), userId: String(userId)})
        })
      },

      role: {
        getAll: action('Getting roles', 'role.getAll')
      },

      docker: {
        start: action('Start a Docker Container', 'docker.start', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        stop: action('Stop a Docker Container', 'docker.stop', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        pause: action('Pause a Docker Container', 'docker.pause', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        unpause: action('Resume a Docker Container', 'docker.unpause', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        restart: action('Restart a Docker Container', 'docker.restart', {
          argsMapper: (vm, container) => ({vm, container})
        })
      },

      vm: {
        attachDisk: action('Attach disk to VM', 'vm.attachDisk', {
          argsMapper: (vm, vdi, bootable, mode, position) => ({vm, vdi, bootable, mode, position})
        }),
        convert: action('Convert VM', 'vm.convert'),
        clone: action('Copy VM', 'vm.clone', {
          // todo : sr ref to choose target SR
          argsMapper: (id, name, full_copy) => ({id, name, full_copy})
        }),
        createInterface: action('Create network interface', 'vm.createInterface', {
          argsMapper: (vm, network, position, mtu, mac) => ({vm, network, position, mtu, mac})
        }),
        createSnapshot: action('Create VM snapshot', 'vm.snapshot', {
          argsMapper: (id, name) => ({id, name})
        }),
        export: action('Export VM', 'vm.export', {
          argsMapper: (vm, compress = true) => ({vm, compress})
        }),
        delete: action('Delete VM', 'vm.delete', {
          argsMapper: (id, delete_disks) => ({ id, delete_disks })
        }),
        ejectCd: action('Eject disc', 'vm.ejectCd'),
        insertCd: action('Insert disc', 'vm.insertCd', {
          argsMapper: (id, cd_id, force = false) => ({ id, cd_id, force })
        }),
        import: action('Import VM', 'vm.import', {
          argsMapper: (host) => ({ host })
        }),
        migrate: action('Migrate VM', 'vm.migrate', {
          argsMapper: (id, host_id) => ({ id, host_id })
        }),
        migratePool: action('Migrate VM to another pool', 'vm.migrate_pool'),
        restart: action('Restart VM', 'vm.restart', {
          argsMapper: (id, force = false) => ({ id, force })
        }),
        start: action('Start VM', 'vm.start'),
        stop: action('Stop VM', 'vm.stop', {
          argsMapper: (id, force = false) => ({ id, force })
        }),
        revert: action('Revert snapshot', 'vm.revert'),
        suspend: action('Suspend VM', 'vm.suspend'),
        resume: action('Resume VM', 'vm.resume', {
          argsMapper: (id, force = true) => ({ id, force })
        }),
        refreshStats: action('Get Stats', 'vm.stats', {
          notification: false
        }),
        // TODO: create/set/pause
        connectPci: action('Connect PCI device', 'vm.attachPci', {
          argsMapper: (vm, pciId) => ({vm, pciId})
        }),
        disconnectPci: action('Disconnect PCI device', 'vm.detachPci', {
          argsMapper: (vm) => ({vm})
        })
      },

      vdi: {
        delete: action('Delete VDI', 'vdi.delete'),
        migrate: action('Migrate VDI', 'vdi.migrate', {
          argsMapper: (id, sr_id) => ({ id, sr_id })
        })
      },

      vif: {
        delete: action('Delete VIF', 'vif.delete'),
        disconnect: action('Disconnect VIF', 'vif.disconnect'),
        connect: action('Connect VIF', 'vif.connect')
      },

      vbd: {
        delete: action('Delete VBD', 'vbd.delete'),
        disconnect: action('Disconnect VBD', 'vbd.disconnect'),
        connect: action('Connect VBD', 'vbd.connect')
      },

      job: {
        getAll: action('Get All jobs', 'job.getAll'),
        create: action('Create a job', 'job.create', {
          argsMapper: (job) => ({job})
        }),
        set: action('Modify a job', 'job.set', {
          argsMapper: (job) => ({job})
        }),
        delete: action('Delete a job', 'job.delete', {
          argsMapper: (id) => ({id})
        })
      },

      schedule: {
        getAll: action('Get all schedules', 'schedule.getAll'),
        create: action('Create a schedule', 'schedule.create', {
          argsMapper: (jobId, cron, enabled) => ({jobId, cron, enabled})
        }),
        set: action('Modify a schedule', 'schedule.set', {
          argsMapper: (id, jobId = undefined, cron = undefined, enabled = undefined) => {
            const args = {id}
            jobId !== undefined && (args.jobId = jobId)
            cron !== undefined && (args.cron = cron)
            enabled !== undefined && (args.enabled = enabled)
            return args
          }
        }),
        delete: action('Delete a schedule', 'schedule.delete', {
          argsMapper: (id) => ({id})
        })
      },

      scheduler: {
        getScheduleTable: action('Get schedule state map', 'scheduler.getScheduleTable'),
        enable: action('Enable a schedule', 'scheduler.enable', {
          argsMapper: (id) => ({id})
        }),
        disable: action('Disable a schedule', 'scheduler.disable', {
          argsMapper: (id) => ({id})
        })
      },

      remote: {
        getAll: action('Get all fs remote points', 'remote.getAll'),
        create: action('Create a fs remote point', 'remote.create', {
          argsMapper: (name, url) => ({name, url})
        }),
        set: action('Modify a fs remote point', 'remote.set', {
          argsMapper: (id, name = undefined, url = undefined, enabled = undefined) => {
            const args = {id}
            name !== undefined && (args.name = name)
            url !== undefined && (args.url = url)
            enabled !== undefined && (args.enabled = enabled)
            return args
          }
        }),
        delete: action('Delete a fs remote point', 'remote.delete', {
          argsMapper: (id) => ({id})
        })
      }
    }

    // Adds the dynamic properties.
    Object.defineProperties(xo, {
      get: {
        get () {
          throw new Error('use xoApi.get() instead')
        }
      }
    })

    // Returns the interface.
    return xo
  })
  .filter('xoHideUnauthorized', (xoApi) => {
    const {canAccess} = xoApi

    return (objects) => filter(objects, canAccess)
  })
  .name
