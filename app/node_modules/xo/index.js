import angular from 'angular'
import filter from 'lodash.filter'
import xoApi from 'xo-api'
import xoNotify from 'xo-notify'

const {isString} = angular

const isPlainObject = (function (toS) {
  const ref = toS.call({})
  return (value) => value != null && toS.call(value) === ref
})(Object.prototype.toString)

// ===================================================================

// High level integration of XO API in xo-web.
export default angular.module('xo', [
  xoApi,
  xoNotify
])
  .service('xo', function (xoApi, xoNotify) {
    // FIXME: default mapper should be identity.
    const defaultArgsMapper = (...args) => {
      const {length} = args

      // No arguments.
      if (!length) {
        return {}
      }

      if (length !== 1) {
        throw new Error('no obvious mapping: more than one argument')
      }

      const arg = args[0]

      // The only argument is an object, it is probably the arguments,
      // therefore it should be forwarded.
      if (isPlainObject(arg)) {
        return arg
      }

      // The only argument is a string, attempts to match it as `id`.
      if (isString(arg)) {
        return { id: arg }
      }

      throw new Error('no obvious mapping: the only argument is neither an object or a string')
    }

    const action = (name, method, options) => {
      if (!method) {
        return () => {
          xoNotify.info({
            title: name,
            message: 'This feature has not been implemented yet.'
          })

          // TODO: A (broken) promise should be returned for
          // consistency.
        }
      }

      const {
        argsMapper = defaultArgsMapper,
        notification
      } = options || {}

      return (...args) => {
        const promise = xoApi.call(method, argsMapper(...args))

        promise.catch(error => {
          console.error('Error for %s:', method, error)

          if (notification !== false) {
            let message

            if (error) {
              const code = error.code

              if (code === 2) {
                message = 'You don\'t have the permission.'
              } else if (code === 5) {
                message = error.data
              } else if (code === 6) {
                message = error.message[0].toUpperCase() + error.message.slice(1) + '.'
              }
            }

            if (!message) {
              message = 'The action failed for unknown reason.'
            }

            xoNotify.warning({
              title: name,
              message
            })
          }
        })

        return promise
      }
    }

    /* eslint key-spacing: 0 */

    // The interface.
    const xo = {
      acl: {
        add: action('Adding an ACL entry', 'acl.add', {
          argsMapper: (subject, object, action) => ({subject, object, action})
        }),
        get: action('Getting ACLs', 'acl.get'),
        remove: action('Remove an ACL entry', 'acl.remove', {
          argsMapper: (subject, object, action) => ({subject, object, action})
        })
      },

      disk: {
        create: action('Create disk', 'disk.create', {
          argsMapper: (name, size, sr) => ({name, size, sr})
        }),
        resize: action('Resize disk', 'disk.resize', {
          argsMapper: (id, size) => ({id, size})
        })
      },

      pool: {
        disconnect: action('Disconnect pool'),
        new_sr: action('New SR'), // temp fix before creating SR
        patch: action('Upload patch', 'pool.patch', {
          argsMapper: (pool) => ({pool})
        }),
        mergeInto: action('Merge pools', 'pool.mergeInto'),
        setDefaultSr: action('Set the default SR', 'pool.setDefaultSr', {
          argsMapper: (pool, sr) => ({pool, sr})
        }),
        getLicenseState: action('Get license state', 'pool.getLicenseState', {
          argsMapper: (pool) => ({pool})
        })
      },

      host: {
        attach:           action('Attach host'),
        detach:           action('Detach host', 'host.detach'),
        restart:          action('Restart host', 'host.restart'),
        restartToolStack: action('Restart tool stack', 'host.restart_agent'),
        start:            action('Start host', 'host.start'),
        enable:           action('Enable host', 'host.enable'),
        stop:             action('Stop host', 'host.stop'),
        disable:          action('Disable host', 'host.disable'),
        new_sr:           action('New SR'), // temp fix before creating SR
        listMissingPatches: action('Check available patches', 'host.listMissingPatches', {
          argsMapper: (host) => ({host})
        }),
        installPatch: action('Install a patch from a patch id', 'host.installPatch', {
          argsMapper: (host, patch) => ({host, patch})
        }),
        installAllPatches: action('Install all the missing patches on a host', 'host.installAllPatches', {
          argsMapper: (host) => ({host})
        }),
        emergencyShutdownHost: action('Suspend all VMs running on host and shutdown host', 'host.emergencyShutdownHost', {
          argsMapper: (host) => ({host})
        }),
        refreshStats: action('Get Stats', 'host.stats', {
          notification: false,
          argsMapper: (host, granularity) => ({host, granularity})
        })
        // TODO: attach/set
      },

      log: {
        delete: action('Delete Log', 'message.delete')
      },
      logs: {
        get: action('Returns logs for one namespace', 'log.get', {
          argsMapper: (namespace) => ({namespace})
        }),
        delete: action('Delete on or several logs for one namespace', 'log.delete', {
          argsMapper: (namespace, id) => ({namespace, id})
        })
      },
      message: {
        delete: action('Delete message')
      },

      pbd: {
        delete: action('Delete PBD', 'pbd.delete'),
        disconnect: action('Disconnect PBD', 'pbd.disconnect'),
        connect: action('Connect PBD', 'pbd.connect')
      },

      server: {
        add: action('Add server', 'server.add'),
        remove: action('Remove server', 'server.remove'),
        getAll: action('Getting server', 'server.getAll'),
        set: action('Save server', 'server.set'),
        connect: action('Connect to a server', 'server.connect', {
          notification: false
        }),
        disconnect: action('Disconnect from a server', 'server.disconnect')
      },

      task: {
        cancel: action('Cancel task', 'task.cancel'),
        destroy: action('Destroy task', 'task.destroy')
      },

      user: {
        create: action('Create user', 'user.create'),
        delete: action('Delete user', 'user.delete', {
          argsMapper: (id) => ({ id: String(id) })
        }),
        getAll: action('Getting users', 'user.getAll'),
        set: action('Save user', 'user.set'),
        changePassword: action('Change user password', 'user.changePassword', {
          notification: false,
          argsMapper: (oldPassword, newPassword) => ({
            oldPassword: String(oldPassword),
            newPassword: String(newPassword)
          })
        })
      },

      group: {
        create: action('Create group', 'group.create'),
        delete: action('Delete group', 'group.delete', {
          argsMapper: (id) => ({ id: String(id) })
        }),
        getAll: action('Getting groups', 'group.getAll'),
        set: action('Save group', 'group.set'),
        setUsers: action('Set group users', 'group.setUsers', {
          argsMapper: (id, userIds) => ({ id: String(id), userIds })
        }),
        addUser: action('Add group user', 'group.addUser', {
          argsMapper: (id, userId) => ({ id: String(id), userId: String(userId) })
        }),
        removeUser: action('Remove group users', 'group.removeUser', {
          argsMapper: (id, userId) => ({ id: String(id), userId: String(userId) })
        })
      },

      role: {
        getAll: action('Getting roles', 'role.getAll')
      },

      docker: {
        start: action('Start a Docker Container', 'docker.start', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        stop: action('Stop a Docker Container', 'docker.stop', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        pause: action('Pause a Docker Container', 'docker.pause', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        unpause: action('Resume a Docker Container', 'docker.unpause', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        restart: action('Restart a Docker Container', 'docker.restart', {
          argsMapper: (vm, container) => ({vm, container})
        }),
        register: action('Register the VM for the Docker plugin', 'docker.register', {
          argsMapper: (vm) => ({ vm })
        }),
        deregister: action('Deregister the VM for the Docker plugin', 'docker.deregister', {
          argsMapper: (vm) => ({ vm })
        })
      },

      vm: {
        attachDisk: action('Attach disk to VM', 'vm.attachDisk', {
          argsMapper: (vm, vdi, bootable, mode, position) => ({vm, vdi, bootable, mode, position})
        }),
        convert: action('Convert VM', 'vm.convert'),
        copy: action('Copy a VM to another SR', 'vm.copy', {
          argsMapper: (vm, sr, name = undefined) => ({vm, sr, name})
        }),
        clone: action('Copy VM', 'vm.clone', {
          // todo : sr ref to choose target SR
          argsMapper: (id, name, full_copy) => ({id, name, full_copy})
        }),
        createInterface: action('Create network interface', 'vm.createInterface', {
          argsMapper: (vm, network, position, mtu, mac) => ({vm, network, position, mtu, mac})
        }),
        createSnapshot: action('Create VM snapshot', 'vm.snapshot', {
          argsMapper: (id, name) => ({id, name})
        }),
        export: action('Export VM', 'vm.export', {
          argsMapper: (vm, compress = true, onlyMetadata = false) => ({vm, compress, onlyMetadata})
        }),
        delete: action('Delete VM', 'vm.delete', {
          argsMapper: (id, delete_disks) => ({ id, delete_disks })
        }),
        ejectCd: action('Eject disc', 'vm.ejectCd'),
        insertCd: action('Insert disc', 'vm.insertCd', {
          argsMapper: (id, cd_id, force = false) => ({ id, cd_id, force })
        }),
        import: action('Import VM', 'vm.import', {
          argsMapper: (host) => ({ host })
        }),
        importBackup: action('Imports a VM from a remote point', 'vm.importBackup', {
          argsMapper: (remote, file, sr) => ({ remote, file, sr })
        }),
        importDeltaBackup: action('Imports a delta backup from a remote point', 'vm.importDeltaBackup', {
          argsMapper: (remote, filePath, sr) => ({ remote, filePath, sr })
        }),
        migrate: action('Migrate VM', 'vm.migrate', {
          argsMapper:
            (vm, targetHost, mapVdisSrs = undefined, mapVifsNetworks = undefined, migrationNetwork = undefined) =>
            ({ vm, targetHost, mapVdisSrs, mapVifsNetworks, migrationNetwork })
        }),
        restart: action('Restart VM', 'vm.restart', {
          argsMapper: (id, force = false) => ({ id, force })
        }),
        recoveryStart: action('Start VM in recovery mode', 'vm.recoveryStart'),
        set: action('Set VM parameters', 'vm.set'),
        start: action('Start VM', 'vm.start'),
        stop: action('Stop VM', 'vm.stop', {
          argsMapper: (id, force = false) => ({ id, force })
        }),
        setBootOrder: action('Set the boot order', 'vm.setBootOrder'),
        revert: action('Revert snapshot', 'vm.revert'),
        suspend: action('Suspend VM', 'vm.suspend'),
        resume: action('Resume VM', 'vm.resume', {
          argsMapper: (id, force = true) => ({ id, force })
        }),
        refreshStats: action('Get Stats', 'vm.stats', {
          notification: false,
          argsMapper: (id, granularity) => ({id, granularity})
        }),
        getCloudInitConfig: action('Get Cloud Init Template', 'vm.getCloudInitConfig', {
          argsMapper: (template) => ({ template })
        }),
        createCloudInitConfigDrive: action('Create Cloud Config Drive', 'vm.createCloudInitConfigDrive', {
          argsMapper: (vm, sr, config, coreos) => ({ vm, sr, config, coreos })
        }),
        // TODO: create/set/pause
        connectPci: action('Connect PCI device', 'vm.attachPci', {
          argsMapper: (vm, pciId) => ({vm, pciId})
        }),
        disconnectPci: action('Disconnect PCI device', 'vm.detachPci', {
          argsMapper: (vm) => ({vm})
        })
      },

      vdi: {
        delete: action('Delete VDI', 'vdi.delete'),
        migrate: action('Migrate VDI', 'vdi.migrate', {
          argsMapper: (id, sr_id) => ({ id, sr_id })
        })
      },

      vif: {
        delete: action('Delete VIF', 'vif.delete'),
        disconnect: action('Disconnect VIF', 'vif.disconnect'),
        connect: action('Connect VIF', 'vif.connect')
      },

      vbd: {
        setBootable: action('Set bootable VBD', 'vbd.setBootable', {
          argsMapper: (vbd, bootable) => ({vbd, bootable})
        }),
        delete: action('Delete VBD', 'vbd.delete'),
        disconnect: action('Disconnect VBD', 'vbd.disconnect'),
        connect: action('Connect VBD', 'vbd.connect')
      },

      job: {
        getAll: action('Get All jobs', 'job.getAll'),
        create: action('Create a job', 'job.create', {
          argsMapper: (job) => ({job})
        }),
        set: action('Modify a job', 'job.set', {
          argsMapper: (job) => ({job})
        }),
        delete: action('Delete a job', 'job.delete', {
          argsMapper: (id) => ({id})
        }),
        runSequence: action('Run a sequence of jobs', 'job.runSequence', {
          argsMapper: (idSequence) => ({idSequence})
        })
      },

      schedule: {
        getAll: action('Get all schedules', 'schedule.getAll'),
        create: action('Create a schedule', 'schedule.create', {
          argsMapper: (jobId, cron, enabled, name) => ({jobId, cron, enabled, name})
        }),
        set: action('Modify a schedule', 'schedule.set', {
          argsMapper: (id, jobId = undefined, cron = undefined, enabled = undefined, name = undefined) => {
            const args = {id}
            jobId !== undefined && (args.jobId = jobId)
            cron !== undefined && (args.cron = cron)
            enabled !== undefined && (args.enabled = enabled)
            name !== undefined && (args.name = name)
            return args
          }
        }),
        delete: action('Delete a schedule', 'schedule.delete', {
          argsMapper: (id) => ({id})
        })
      },

      scheduler: {
        getScheduleTable: action('Get schedule state map', 'scheduler.getScheduleTable'),
        enable: action('Enable a schedule', 'scheduler.enable', {
          argsMapper: (id) => ({id})
        }),
        disable: action('Disable a schedule', 'scheduler.disable', {
          argsMapper: (id) => ({id})
        })
      },

      remote: {
        getAll: action('Get all fs remote points', 'remote.getAll'),
        create: action('Create a fs remote point', 'remote.create', {
          argsMapper: (name, url) => ({name, url})
        }),
        set: action('Modify a fs remote point', 'remote.set', {
          argsMapper: (id, name = undefined, url = undefined, enabled = undefined) => {
            const args = {id}
            name !== undefined && (args.name = name)
            url !== undefined && (args.url = url)
            enabled !== undefined && (args.enabled = enabled)
            return args
          }
        }),
        delete: action('Delete a fs remote point', 'remote.delete', {
          argsMapper: (id) => ({id})
        }),
        list: action('List files found at the remote point', 'remote.list', {
          argsMapper: id => ({id})
        })
      },

      tag: {
        add: action('Add a tag to an object', 'tag.add', {
          argsMapper: (tag, id) => ({tag, id})
        }),
        remove: action('Remove a tag from an object', 'tag.remove', {
          argsMapper: (tag, id) => ({tag, id})
        })
      },

      plugin: {
        get: action('Returns a list of all installed plugins', 'plugin.get'),
        configure: action('Sets the configuration a plugin', 'plugin.configure', {
          argsMapper: (id, configuration) => ({id, configuration})
        }),
        disableAutoload: action('Plugin will not be loaded automatically at server start', 'plugin.disableAutoload', {
          argsMapper: (id) => ({id})
        }),
        enableAutoload: action('Ask for plugin to be loaded automatically at server start', 'plugin.enableAutoload', {
          argsMapper: (id) => ({id})
        }),
        load: action('Loads a plugin', 'plugin.load', {
          argsMapper: (id) => ({id})
        }),
        unload: action('Unloads a plugin', 'plugin.unload', {
          argsMapper: (id) => ({id})
        }),
        purgeConfiguration: action('Purge a plugin configuration', 'plugin.purgeConfiguration', {
          argsMapper: (id) => ({id})
        })
      },

      resourceSet: {
        create: action('Create a named resource set', 'resourceSet.create', {
          argsMapper: (name, subjects = undefined, objects = undefined, limits = undefined) => ({
            name, subjects, objects, limits
          })
        }),
        delete: action('Delete a resource set', 'resourceSet.delete', {
          argsMapper: (id) => ({id})
        }),
        get: action('Get a resource set ', 'resourceSet.get', {
          argsMapper: (id) => ({id})
        }),
        getAll: action('Get all resource sets', 'resourceSet.getAll'),
        addObject: action('Add an object to a resource set', 'resourceSet.addObject', {
          argsMapper: (id, object) => ({id, object})
        }),
        removeObject: action('Remove an object from a resource set', 'resourceSet.removeObject', {
          argsMapper: (id, object) => ({id, object})
        }),
        addSubject: action('Add a subject to a resource set', 'resourceSet.addSubject', {
          argsMapper: (id, object) => ({id, object})
        }),
        removeSubject: action('Remove a subject from a resource set', 'resourceSet.removeSubject', {
          argsMapper: (id, subject) => ({id, subject})
        }),
        set: action('Set the properties of a resource set', 'resourceSet.set', {
          argsMapper: (id, name = undefined, subjects = undefined, objects = undefined, limits = undefined) => ({
            id, name, subjects, objects, limits
          })
        })
      },

      system: {
        getServerVersion: action('Get the server version', 'system.getServerVersion')
      }
    }

    // Adds the dynamic properties.
    Object.defineProperties(xo, {
      get: {
        get () {
          throw new Error('use xoApi.get() instead')
        }
      }
    })

    // Returns the interface.
    return xo
  })
  .filter('xoHideUnauthorized', (xoApi) => {
    const {canAccess} = xoApi

    return (objects) => filter(objects, canAccess)
  })
  .name
