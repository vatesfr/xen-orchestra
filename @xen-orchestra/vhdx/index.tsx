// code generated by claude 

import { RandomAccessDisk, DiskBlock } from '@xen-orchestra/disk-transform'
import type { FileHandle } from 'fs/promises'

// VHDX Constants
const VHDX_SIGNATURE = Buffer.from('vhdxfile')
const VHDX_HEADER_SIGNATURE = Buffer.from('head')
const VHDX_REGION_TABLE_SIGNATURE = Buffer.from('regi')
const VHDX_LOG_SIGNATURE = Buffer.from('loge')
const VHDX_METADATA_SIGNATURE = Buffer.from('metadata')
const VHDX_BAT_SIGNATURE = Buffer.from('bat\0')
const VHDX_PARENT_LOCATOR_SIGNATURE = Buffer.from('parent_linkage')

const KB = 1024
const MB = 1024 * KB
const VHDX_HEADER_SIZE = 64 * KB
const VHDX_REGION_TABLE_SIZE = 64 * KB

// VHDX GUIDs
const BAT_GUID = '2dc27766f62342009d64115e9bfd4a08'
const METADATA_GUID = '8b7ca20647904b9aba8fe8289ed58fff'

// Metadata item GUIDs
const FILE_PARAMETERS_GUID = 'caa16737fa364d43b3b633f0aa44e76b'
const VIRTUAL_DISK_SIZE_GUID = '2fa54224cd1b4876b211745d45bb85a4'
const VIRTUAL_DISK_ID_GUID = 'beca12abffe9384fb77261e8ee712f16'
const LOGICAL_SECTOR_SIZE_GUID = '8141bf1dace94aa0a7e1f05a7b8c4f40'
const PHYSICAL_SECTOR_SIZE_GUID = 'cda348c7445d44718b9dce6949d09c0b'
const PARENT_LOCATOR_GUID = 'a8d35f2db30b454d89acda70a3c8c9a3'

interface VhdxHeader {
  signature: Buffer
  checksum: number
  sequenceNumber: bigint
  fileWriteGuid: Buffer
  dataWriteGuid: Buffer
  logGuid: Buffer
  logVersion: number
  version: number
  logLength: number
  logOffset: bigint
}

interface VhdxRegionTableEntry {
  guid: Buffer
  fileOffset: bigint
  length: number
  required: boolean
}

interface VhdxMetadataTableEntry {
  itemId: Buffer
  offset: number
  length: number
  isUser: boolean
  isVirtualDisk: boolean
  isRequired: boolean
}

interface VhdxFileParameters {
  blockSize: number
  leaveBlocksAllocated: boolean
  hasParent: boolean
}

interface BatEntry {
  state: number
  reserved: number
  fileOffsetMB: bigint
}

export class RandomAccessVhdx extends RandomAccessDisk {
  #fd: FileHandle
  #header?: VhdxHeader
  #batOffset: bigint = 0n
  #batLength: number = 0
  #metadataOffset: bigint = 0n
  #metadataLength: number = 0
  #blockSize: number = 0
  #virtualSize: bigint = 0n
  #virtualDiskId?: Buffer
  #hasParent: boolean = false
  #parentLocatorEntries: any[] = []
  #parentPath?: string
  #chunkRatio: number = 0
  #totalBatEntries: number = 0
  #logicalSectorSize: number = 512
  #batCache?: BatEntry[]

  constructor(fd: FileHandle) {
    super()
    this.#fd = fd
  }

  async init(): Promise<void> {
    // Read and validate file identifier
    await this.#readFileIdentifier()
    
    // Read headers (there are 2, we need to find the current one)
    this.#header = await this.#readCurrentHeader()
    
    // Read region table to find BAT and Metadata
    await this.#readRegionTable()
    
    // Read metadata
    await this.#readMetadata()
    
    // Calculate derived values
    this.#calculateDerivedValues()
    
    // Read BAT (Block Allocation Table)
    await this.#readBAT()
  }

  async close(): Promise<void> {
    // No need to close fd here, it's managed externally
  }

  getVirtualSize(): number {
    return Number(this.#virtualSize)
  }

  getBlockSize(): number {
    return this.#blockSize
  }

  isDifferencing(): boolean {
    return this.#hasParent
  }

  instantiateParent(): RandomAccessDisk {
    if (!this.#hasParent || !this.#parentPath) {
      throw new Error('This VHDX does not have a parent')
    }
    // This would need to be implemented based on how you want to handle parent disk instantiation
    throw new Error('Parent instantiation not implemented - requires path to parent disk')
  }

  getVirtualDiskId(): string | undefined {
    return this.#virtualDiskId?.toString('hex')
  }

  getParentPath(): string | undefined {
    return this.#parentPath
  }

  getBlockIndexes(): Array<number> {
    const indexes: number[] = []
    if (!this.#batCache) {
      return indexes
    }

    for (let i = 0; i < this.#batCache.length; i++) {
      const entry = this.#batCache[i]
      if (entry.state === 6) { // PAYLOAD_BLOCK_FULLY_PRESENT
        indexes.push(i)
      }
    }
    return indexes
  }

  hasBlock(index: number): boolean {
    if (!this.#batCache || index >= this.#batCache.length) {
      return false
    }
    const entry = this.#batCache[index]
    return entry.state === 6 // PAYLOAD_BLOCK_FULLY_PRESENT
  }

  async readBlock(index: number): Promise<DiskBlock> {
    if (!this.#batCache) {
      throw new Error('BAT not loaded')
    }

    if (index >= this.#batCache.length) {
      throw new Error(`Block index ${index} out of range`)
    }

    const entry = this.#batCache[index]
    
    // If block is not present in this disk, try parent
    if (entry.state !== 6) { // Not PAYLOAD_BLOCK_FULLY_PRESENT
      if (this.#hasParent && this.parent) {
        return this.parent.readBlock(index)
      }
      // Return zeroed block
      return {
        index,
        data: Buffer.alloc(this.#blockSize)
      }
    }

    // Read block data from file
    const fileOffset = entry.fileOffsetMB * BigInt(MB)
    const data = Buffer.alloc(this.#blockSize)
    await this.#fd.read(data, 0, this.#blockSize, Number(fileOffset))

    return {
      index,
      data
    }
  }

  // Private methods for reading VHDX structures

  async #readFileIdentifier(): Promise<void> {
    const buffer = Buffer.alloc(64 * KB)
    await this.#fd.read(buffer, 0, 64 * KB, 0)

    const signature = buffer.subarray(0, 8)
    if (!signature.equals(VHDX_SIGNATURE)) {
      throw new Error('Invalid VHDX file signature')
    }
  }

  async #readCurrentHeader(): Promise<VhdxHeader> {
    // VHDX has two headers at 64KB and 128KB, use the one with highest sequence number
    const header1 = await this.#readHeader(64 * KB)
    const header2 = await this.#readHeader(128 * KB)

    return header1.sequenceNumber > header2.sequenceNumber ? header1 : header2
  }

  async #readHeader(offset: number): Promise<VhdxHeader> {
    const buffer = Buffer.alloc(4 * KB)
    await this.#fd.read(buffer, 0, 4 * KB, offset)

    const signature = buffer.subarray(0, 4)
    if (!signature.equals(VHDX_HEADER_SIGNATURE)) {
      throw new Error('Invalid VHDX header signature')
    }

    return {
      signature,
      checksum: buffer.readUInt32LE(4),
      sequenceNumber: buffer.readBigUInt64LE(8),
      fileWriteGuid: buffer.subarray(16, 32),
      dataWriteGuid: buffer.subarray(32, 48),
      logGuid: buffer.subarray(48, 64),
      logVersion: buffer.readUInt16LE(64),
      version: buffer.readUInt16LE(66),
      logLength: buffer.readUInt32LE(68),
      logOffset: buffer.readBigUInt64LE(72)
    }
  }

  async #readRegionTable(): Promise<void> {
    const buffer = Buffer.alloc(64 * KB)
    await this.#fd.read(buffer, 0, 64 * KB, 192 * KB) // Region table starts at 192KB

    const signature = buffer.subarray(0, 4)
    if (!signature.equals(VHDX_REGION_TABLE_SIGNATURE)) {
      throw new Error('Invalid VHDX region table signature')
    }

    const entryCount = buffer.readUInt32LE(8)

    for (let i = 0; i < entryCount; i++) {
      const entryOffset = 16 + (i * 32)
      const guid = buffer.subarray(entryOffset, entryOffset + 16)
      const guidString = this.#formatGuid(guid)
      const fileOffset = buffer.readBigUInt64LE(entryOffset + 16)
      const length = buffer.readUInt32LE(entryOffset + 24)
      const required = (buffer.readUInt32LE(entryOffset + 28) & 1) === 1

      if (guidString === BAT_GUID) {
        this.#batOffset = fileOffset
        this.#batLength = length
      } else if (guidString === METADATA_GUID) {
        this.#metadataOffset = fileOffset
        this.#metadataLength = length
      }
    }

    if (this.#batOffset === 0n || this.#metadataOffset === 0n) {
      throw new Error('Could not find BAT or Metadata regions')
    }
  }

  async #readMetadata(): Promise<void> {
    const buffer = Buffer.alloc(this.#metadataLength)
    await this.#fd.read(buffer, 0, this.#metadataLength, Number(this.#metadataOffset))

    const signature = buffer.subarray(0, 8)
    if (!signature.equals(VHDX_METADATA_SIGNATURE)) {
      throw new Error('Invalid VHDX metadata signature')
    }

    const entryCount = buffer.readUInt16LE(10)
    const entries: VhdxMetadataTableEntry[] = []

    for (let i = 0; i < entryCount; i++) {
      const entryOffset = 32 + (i * 32)
      const itemId = buffer.subarray(entryOffset, entryOffset + 16)
      const offset = buffer.readUInt32LE(entryOffset + 16)
      const length = buffer.readUInt32LE(entryOffset + 20)
      const flags = buffer.readUInt32LE(entryOffset + 24)

      entries.push({
        itemId,
        offset,
        length,
        isUser: (flags & 1) === 1,
        isVirtualDisk: (flags & 2) === 2,
        isRequired: (flags & 4) === 4
      })
    }

    // Read metadata items
    for (const entry of entries) {
      const guidString = this.#formatGuid(entry.itemId)
      const itemData = buffer.subarray(entry.offset, entry.offset + entry.length)

      switch (guidString) {
        case FILE_PARAMETERS_GUID:
          this.#readFileParameters(itemData)
          break
        case VIRTUAL_DISK_SIZE_GUID:
          this.#virtualSize = itemData.readBigUInt64LE(0)
          break
        case VIRTUAL_DISK_ID_GUID:
          this.#virtualDiskId = Buffer.from(itemData)
          break
        case LOGICAL_SECTOR_SIZE_GUID:
          this.#logicalSectorSize = itemData.readUInt32LE(0)
          break
        case PARENT_LOCATOR_GUID:
          this.#readParentLocator(itemData)
          break
      }
    }
  }

  #readFileParameters(data: Buffer): void {
    this.#blockSize = data.readUInt32LE(0)
    const flags = data.readUInt32LE(4)
    this.#hasParent = (flags & 1) === 1
  }

  #readParentLocator(data: Buffer): void {
    const locatorType = data.subarray(0, 16)
    const keyValueCount = data.readUInt16LE(18)

    let offset = 20
    for (let i = 0; i < keyValueCount; i++) {
      const keyOffset = data.readUInt32LE(offset)
      const valueOffset = data.readUInt32LE(offset + 4)
      const keyLength = data.readUInt16LE(offset + 8)
      const valueLength = data.readUInt16LE(offset + 10)

      const key = data.subarray(keyOffset, keyOffset + keyLength).toString('utf16le').replace(/\0/g, '')
      const value = data.subarray(valueOffset, valueOffset + valueLength).toString('utf16le').replace(/\0/g, '')

      this.#parentLocatorEntries.push({ key, value })

      if (key === 'relative_path' || key === 'absolute_win32_path') {
        this.#parentPath = value
      }

      offset += 12
    }
  }

  #calculateDerivedValues(): void {
    // Calculate chunk ratio (2^23 = 8MB / blockSize)
    const chunkSize = 8 * MB
    this.#chunkRatio = Math.floor(chunkSize / this.#blockSize)
    
    // Calculate total BAT entries
    const dataBlocksCount = Number((this.#virtualSize + BigInt(this.#blockSize) - 1n) / BigInt(this.#blockSize))
    const sectorBitmapBlocksCount = Math.ceil(dataBlocksCount / this.#chunkRatio)
    this.#totalBatEntries = dataBlocksCount + ((dataBlocksCount - 1) / this.#chunkRatio)
  }

  async #readBAT(): Promise<void> {
    const batSizeBytes = Math.ceil(this.#totalBatEntries * 8) // Each entry is 8 bytes
    const buffer = Buffer.alloc(batSizeBytes)
    await this.#fd.read(buffer, 0, batSizeBytes, Number(this.#batOffset))

    this.#batCache = []
    
    for (let i = 0; i < this.#totalBatEntries; i++) {
      const offset = i * 8
      const entry = buffer.readBigUInt64LE(offset)
      
      const state = Number(entry & 0x7n) // Lower 3 bits
      const reserved = Number((entry >> 3n) & 0x1FFFFFFFFFFFFFn) // Next 17 bits
      const fileOffsetMB = entry >> 20n // Upper 44 bits

      this.#batCache.push({
        state,
        reserved,
        fileOffsetMB
      })
    }
  }

  #formatGuid(buffer: Buffer): string {
    // Convert GUID from little-endian format to string
    const d1 = buffer.readUInt32LE(0).toString(16).padStart(8, '0')
    const d2 = buffer.readUInt16LE(4).toString(16).padStart(4, '0')
    const d3 = buffer.readUInt16LE(6).toString(16).padStart(4, '0')
    const d4 = buffer.subarray(8, 10).toString('hex')
    const d5 = buffer.subarray(10, 16).toString('hex')
    return `${d1}${d2}${d3}${d4}${d5}`
  }
}
